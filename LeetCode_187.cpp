class Solution
{
public:

    vector<string> findRepeatedDnaSequences(string s)
    {
        if (s.length() < 10)
        {
            return vector<string>();
        }
        
        int iStrInit = 0;
        unordered_set<int> hmapStrMultiTimes;
        unordered_map<int, int> hmapStrTimes;
        
        for (int iIndex = 0; iIndex < 10; iIndex ++)
        {
            iStrInit = (iStrInit << 2) | DnaBaseCode(s[iIndex]);
        }
        
        hmapStrTimes[iStrInit] = 1;
        
        for (int iIndex = 10, iCurrent = iStrInit; iIndex < s.length(); iIndex ++)
        {
            iCurrent = ((iCurrent << 2) & 0xFFFFF) | DnaBaseCode(s[iIndex]);
            
            if (hmapStrTimes.find(iCurrent) != hmapStrTimes.end())
            {
                hmapStrTimes[iCurrent] ++;
                hmapStrMultiTimes.insert(iCurrent);
            }
            else
            {
                hmapStrTimes[iCurrent] = 1;
            }
        }
        
        vector<string> vecResult;
        
        for (unordered_set<int>::iterator hsetIterator = hmapStrMultiTimes.begin(); hsetIterator != hmapStrMultiTimes.end(); hsetIterator ++)
        {
            vecResult.push_back(SeqCodeToDnaString(*hsetIterator));
        }
        
        return vecResult;
    }
    
private:

    int DnaBaseCode(char cBase)
    {
        switch (cBase)
        {
            case 'A': return 0;
            case 'G': return 1;
            case 'C': return 2;
            case 'T': return 3;
        }
        
        return -1;
    }
    
    string SeqCodeToDnaString(int iSeqCode)
    {
        char aszDstString[11] = { 0 };
        
        for (int iIndex = 0; iIndex < 10; iIndex ++, iSeqCode >>= 2)
        {
            switch (iSeqCode & 0x3)
            {
                case 0: aszDstString[10 - iIndex - 1] = 'A'; break;
                case 1: aszDstString[10 - iIndex - 1] = 'G'; break;
                case 2: aszDstString[10 - iIndex - 1] = 'C'; break;
                case 3: aszDstString[10 - iIndex - 1] = 'T'; break;
            }
        }
        
        return string(aszDstString);
    }
};

/*

Thinking is right, but not bug free. Two compile errors and a string end zero error.

Because of only 4 DNA bases, convert each base to 2 bits.

The string which has length 10 can be converted to a 20 bits integer.

The next integer can be generated by current integer using bit calculation with time complexty O(1).

Using hash table to store and calculate duplication.

Is there a better algorithm? Research it later!

*/
